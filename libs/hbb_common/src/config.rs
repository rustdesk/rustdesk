use std::{
    collections::HashMap,
    fs,
    net::{IpAddr, Ipv4Addr, SocketAddr},
    path::{Path, PathBuf},
    sync::{Arc, Mutex, RwLock},
    time::SystemTime,
};

use anyhow::Result;
use rand::Rng;
use regex::Regex;
use serde as de;
use serde_derive::{Deserialize, Serialize};
use sodiumoxide::base64;
use sodiumoxide::crypto::sign;

use crate::{
    log,
    password_security::{
        decrypt_str_or_original, decrypt_vec_or_original, encrypt_str_or_original,
        encrypt_vec_or_original,
    },
};

pub const RENDEZVOUS_TIMEOUT: u64 = 12_000;
pub const CONNECT_TIMEOUT: u64 = 18_000;
pub const READ_TIMEOUT: u64 = 30_000;
pub const REG_INTERVAL: i64 = 12_000;
pub const COMPRESS_LEVEL: i32 = 3;
const SERIAL: i32 = 3;
const PASSWORD_ENC_VERSION: &'static str = "00";
// 128x128
#[cfg(target_os = "macos")] // 128x128 on 160x160 canvas, then shrink to 128, mac looks better with padding
pub const ICON: &str = "data:image/png;base64,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
";
#[cfg(not(target_os = "macos"))] // 128x128 no padding
pub const ICON: &str = "data:image/png;base64,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
";
#[cfg(target_os = "macos")]
lazy_static::lazy_static! {
    pub static ref ORG: Arc<RwLock<String>> = Arc::new(RwLock::new("com.carriez".to_owned()));
}

type Size = (i32, i32, i32, i32);

lazy_static::lazy_static! {
    static ref CONFIG: Arc<RwLock<Config>> = Arc::new(RwLock::new(Config::load()));
    static ref CONFIG2: Arc<RwLock<Config2>> = Arc::new(RwLock::new(Config2::load()));
    static ref LOCAL_CONFIG: Arc<RwLock<LocalConfig>> = Arc::new(RwLock::new(LocalConfig::load()));
    pub static ref ONLINE: Arc<Mutex<HashMap<String, i64>>> = Default::default();
    pub static ref PROD_RENDEZVOUS_SERVER: Arc<RwLock<String>> = Default::default();
    pub static ref APP_NAME: Arc<RwLock<String>> = Arc::new(RwLock::new("GerarDesk".to_owned()));
    static ref KEY_PAIR: Arc<Mutex<Option<(Vec<u8>, Vec<u8>)>>> = Default::default();
    static ref HW_CODEC_CONFIG: Arc<RwLock<HwCodecConfig>> = Arc::new(RwLock::new(HwCodecConfig::load()));
}

lazy_static::lazy_static! {
    pub static ref APP_DIR: Arc<RwLock<String>> = Default::default();
}

#[cfg(any(target_os = "android", target_os = "ios"))]
lazy_static::lazy_static! {
    pub static ref APP_HOME_DIR: Arc<RwLock<String>> = Default::default();
}

// #[cfg(any(target_os = "android", target_os = "ios"))]
lazy_static::lazy_static! {
    pub static ref HELPER_URL: HashMap<&'static str, &'static str> = HashMap::from([
        ("rustdesk docs home", "https://rustdesk.com/docs/en/"),
        ("rustdesk docs x11-required", "https://rustdesk.com/docs/en/manual/linux/#x11-required"),
        ]);
}

const CHARS: &'static [char] = &[
    '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
    'm', 'n', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
];

pub const RENDEZVOUS_SERVERS: &'static [&'static str] = &[
    "187.102.175.251",
];
pub const RS_PUB_KEY: &'static str = "WipVQNpGrZYXPpUTCxdauF6qbJnQh9PovJz3t2dCu5Q=";
pub const RENDEZVOUS_PORT: i32 = 21116;
pub const RELAY_PORT: i32 = 21117;

macro_rules! serde_field_string {
    ($default_func:ident, $de_func:ident, $default_expr:expr) => {
        fn $default_func() -> String {
            $default_expr
        }

        fn $de_func<'de, D>(deserializer: D) -> Result<String, D::Error>
        where
            D: de::Deserializer<'de>,
        {
            let s: &str = de::Deserialize::deserialize(deserializer)?;
            Ok(if s.is_empty() {
                Self::$default_func()
            } else {
                s.to_owned()
            })
        }
    };
}

#[derive(Clone, Copy, PartialEq, Eq, Debug)]
pub enum NetworkType {
    Direct,
    ProxySocks,
}

#[derive(Debug, Default, Serialize, Deserialize, Clone, PartialEq)]
pub struct Config {
    #[serde(default)]
    pub id: String, // use
    #[serde(default)]
    enc_id: String, // store
    #[serde(default)]
    password: String,
    #[serde(default)]
    salt: String,
    #[serde(default)]
    key_pair: (Vec<u8>, Vec<u8>), // sk, pk
    #[serde(default)]
    key_confirmed: bool,
    #[serde(default)]
    keys_confirmed: HashMap<String, bool>,
}

#[derive(Debug, Default, PartialEq, Serialize, Deserialize, Clone)]
pub struct Socks5Server {
    #[serde(default)]
    pub proxy: String,
    #[serde(default)]
    pub username: String,
    #[serde(default)]
    pub password: String,
}

// more variable configs
#[derive(Debug, Default, Serialize, Deserialize, Clone, PartialEq)]
pub struct Config2 {
    #[serde(default)]
    rendezvous_server: String,
    #[serde(default)]
    nat_type: i32,
    #[serde(default)]
    serial: i32,

    #[serde(default)]
    socks: Option<Socks5Server>,

    // the other scalar value must before this
    #[serde(default)]
    pub options: HashMap<String, String>,
}

#[derive(Debug, Default, Serialize, Deserialize, Clone, PartialEq)]
pub struct PeerConfig {
    #[serde(default)]
    pub password: Vec<u8>,
    #[serde(default)]
    pub size: Size,
    #[serde(default)]
    pub size_ft: Size,
    #[serde(default)]
    pub size_pf: Size,
    #[serde(
        default = "PeerConfig::default_view_style",
        deserialize_with = "PeerConfig::deserialize_view_style"
    )]
    pub view_style: String,
    #[serde(
        default = "PeerConfig::default_scroll_style",
        deserialize_with = "PeerConfig::deserialize_scroll_style"
    )]
    pub scroll_style: String,
    #[serde(
        default = "PeerConfig::default_image_quality",
        deserialize_with = "PeerConfig::deserialize_image_quality"
    )]
    pub image_quality: String,
    #[serde(default)]
    pub custom_image_quality: Vec<i32>,
    #[serde(default)]
    pub show_remote_cursor: bool,
    #[serde(default)]
    pub lock_after_session_end: bool,
    #[serde(default)]
    pub privacy_mode: bool,
    #[serde(default)]
    pub port_forwards: Vec<(i32, String, i32)>,
    #[serde(default)]
    pub direct_failures: i32,
    #[serde(default)]
    pub disable_audio: bool,
    #[serde(default)]
    pub disable_clipboard: bool,
    #[serde(default)]
    pub enable_file_transfer: bool,
    #[serde(default)]
    pub show_quality_monitor: bool,

    // The other scalar value must before this
    #[serde(default, deserialize_with = "PeerConfig::deserialize_options")]
    pub options: HashMap<String, String>,
    // Various data for flutter ui
    #[serde(default)]
    pub ui_flutter: HashMap<String, String>,
    #[serde(default)]
    pub info: PeerInfoSerde,
    #[serde(default)]
    pub transfer: TransferSerde,
}

#[derive(Debug, PartialEq, Default, Serialize, Deserialize, Clone)]
pub struct PeerInfoSerde {
    #[serde(default)]
    pub username: String,
    #[serde(default)]
    pub hostname: String,
    #[serde(default)]
    pub platform: String,
}

#[derive(Debug, Default, Serialize, Deserialize, Clone, PartialEq)]
pub struct TransferSerde {
    #[serde(default)]
    pub write_jobs: Vec<String>,
    #[serde(default)]
    pub read_jobs: Vec<String>,
}

fn patch(path: PathBuf) -> PathBuf {
    if let Some(_tmp) = path.to_str() {
        #[cfg(windows)]
        return _tmp
            .replace(
                "system32\\config\\systemprofile",
                "ServiceProfiles\\LocalService",
            )
            .into();
        #[cfg(target_os = "macos")]
        return _tmp.replace("Application Support", "Preferences").into();
        #[cfg(target_os = "linux")]
        {
            if _tmp == "/root" {
                if let Ok(output) = std::process::Command::new("whoami").output() {
                    let user = String::from_utf8_lossy(&output.stdout)
                        .to_string()
                        .trim()
                        .to_owned();
                    if user != "root" {
                        return format!("/home/{}", user).into();
                    }
                }
            }
        }
    }
    path
}

impl Config2 {
    fn load() -> Config2 {
        let mut config = Config::load_::<Config2>("2");
        if let Some(mut socks) = config.socks {
            let (password, _, store) =
                decrypt_str_or_original(&socks.password, PASSWORD_ENC_VERSION);
            socks.password = password;
            config.socks = Some(socks);
            if store {
                config.store();
            }
        }
        config
    }

    pub fn file() -> PathBuf {
        Config::file_("2")
    }

    fn store(&self) {
        let mut config = self.clone();
        if let Some(mut socks) = config.socks {
            socks.password = encrypt_str_or_original(&socks.password, PASSWORD_ENC_VERSION);
            config.socks = Some(socks);
        }
        Config::store_(&config, "2");
    }

    pub fn get() -> Config2 {
        return CONFIG2.read().unwrap().clone();
    }

    pub fn set(cfg: Config2) -> bool {
        let mut lock = CONFIG2.write().unwrap();
        if *lock == cfg {
            return false;
        }
        *lock = cfg;
        lock.store();
        true
    }
}

pub fn load_path<T: serde::Serialize + serde::de::DeserializeOwned + Default + std::fmt::Debug>(
    file: PathBuf,
) -> T {
    let cfg = match confy::load_path(&file) {
        Ok(config) => config,
        Err(err) => {
            log::error!("Failed to load config: {}", err);
            T::default()
        }
    };
    cfg
}

#[inline]
pub fn store_path<T: serde::Serialize>(path: PathBuf, cfg: T) -> crate::ResultType<()> {
    Ok(confy::store_path(path, cfg)?)
}

impl Config {
    fn load_<T: serde::Serialize + serde::de::DeserializeOwned + Default + std::fmt::Debug>(
        suffix: &str,
    ) -> T {
        let file = Self::file_(suffix);
        log::debug!("Configuration path: {}", file.display());
        let cfg = load_path(file);
        if suffix.is_empty() {
            log::trace!("{:?}", cfg);
        }
        cfg
    }

    fn store_<T: serde::Serialize>(config: &T, suffix: &str) {
        let file = Self::file_(suffix);
        if let Err(err) = store_path(file, config) {
            log::error!("Failed to store config: {}", err);
        }
    }

    fn load() -> Config {
        let mut config = Config::load_::<Config>("");
        let mut store = false;
        let (password, _, store1) = decrypt_str_or_original(&config.password, PASSWORD_ENC_VERSION);
        config.password = password;
        store |= store1;
        let mut id_valid = false;
        let (id, encrypted, store2) = decrypt_str_or_original(&config.enc_id, PASSWORD_ENC_VERSION);
        if encrypted {
            config.id = id;
            id_valid = true;
            store |= store2;
        } else {
            if crate::get_modified_time(&Self::file_(""))
                .checked_sub(std::time::Duration::from_secs(30)) // allow modification during installation
                .unwrap_or(crate::get_exe_time())
                < crate::get_exe_time()
            {
                if !config.id.is_empty()
                    && config.enc_id.is_empty()
                    && !decrypt_str_or_original(&config.id, PASSWORD_ENC_VERSION).1
                {
                    id_valid = true;
                    store = true;
                }
            }
        }
        if !id_valid {
            for _ in 0..3 {
                if let Some(id) = Config::get_auto_id() {
                    config.id = id;
                    store = true;
                    break;
                } else {
                    log::error!("Failed to generate new id");
                }
            }
        }
        if store {
            config.store();
        }
        config
    }

    fn store(&self) {
        let mut config = self.clone();
        config.password = encrypt_str_or_original(&config.password, PASSWORD_ENC_VERSION);
        config.enc_id = encrypt_str_or_original(&config.id, PASSWORD_ENC_VERSION);
        config.id = "".to_owned();
        Config::store_(&config, "");
    }

    pub fn file() -> PathBuf {
        Self::file_("")
    }

    fn file_(suffix: &str) -> PathBuf {
        let name = format!("{}{}", *APP_NAME.read().unwrap(), suffix);
        Config::with_extension(Self::path(name))
    }

    pub fn is_empty(&self) -> bool {
        (self.id.is_empty() && self.enc_id.is_empty()) || self.key_pair.0.is_empty()
    }

    pub fn get_home() -> PathBuf {
        #[cfg(any(target_os = "android", target_os = "ios"))]
        return Self::path(APP_HOME_DIR.read().unwrap().as_str());
        #[cfg(not(any(target_os = "android", target_os = "ios")))]
        {
            if let Some(path) = dirs_next::home_dir() {
                patch(path)
            } else if let Ok(path) = std::env::current_dir() {
                path
            } else {
                std::env::temp_dir()
            }
        }
    }

    pub fn path<P: AsRef<Path>>(p: P) -> PathBuf {
        #[cfg(any(target_os = "android", target_os = "ios"))]
        {
            let mut path: PathBuf = APP_DIR.read().unwrap().clone().into();
            path.push(p);
            return path;
        }
        #[cfg(not(any(target_os = "android", target_os = "ios")))]
        {
            #[cfg(not(target_os = "macos"))]
            let org = "";
            #[cfg(target_os = "macos")]
            let org = ORG.read().unwrap().clone();
            // /var/root for root
            if let Some(project) =
                directories_next::ProjectDirs::from("", &org, &*APP_NAME.read().unwrap())
            {
                let mut path = patch(project.config_dir().to_path_buf());
                path.push(p);
                return path;
            }
            return "".into();
        }
    }

    #[allow(unreachable_code)]
    pub fn log_path() -> PathBuf {
        #[cfg(target_os = "macos")]
        {
            if let Some(path) = dirs_next::home_dir().as_mut() {
                path.push(format!("Library/Logs/{}", *APP_NAME.read().unwrap()));
                return path.clone();
            }
        }
        #[cfg(target_os = "linux")]
        {
            let mut path = Self::get_home();
            path.push(format!(".local/share/logs/{}", *APP_NAME.read().unwrap()));
            std::fs::create_dir_all(&path).ok();
            return path;
        }
        if let Some(path) = Self::path("").parent() {
            let mut path: PathBuf = path.into();
            path.push("log");
            return path;
        }
        "".into()
    }

    pub fn ipc_path(postfix: &str) -> String {
        #[cfg(windows)]
        {
            // \\ServerName\pipe\PipeName
            // where ServerName is either the name of a remote computer or a period, to specify the local computer.
            // https://docs.microsoft.com/en-us/windows/win32/ipc/pipe-names
            format!(
                "\\\\.\\pipe\\{}\\query{}",
                *APP_NAME.read().unwrap(),
                postfix
            )
        }
        #[cfg(not(windows))]
        {
            use std::os::unix::fs::PermissionsExt;
            #[cfg(target_os = "android")]
            let mut path: PathBuf =
                format!("{}/{}", *APP_DIR.read().unwrap(), *APP_NAME.read().unwrap()).into();
            #[cfg(not(target_os = "android"))]
            let mut path: PathBuf = format!("/tmp/{}", *APP_NAME.read().unwrap()).into();
            fs::create_dir(&path).ok();
            fs::set_permissions(&path, fs::Permissions::from_mode(0o0777)).ok();
            path.push(format!("ipc{}", postfix));
            path.to_str().unwrap_or("").to_owned()
        }
    }

    pub fn icon_path() -> PathBuf {
        let mut path = Self::path("icons");
        if fs::create_dir_all(&path).is_err() {
            path = std::env::temp_dir();
        }
        path
    }

    #[inline]
    pub fn get_any_listen_addr() -> SocketAddr {
        SocketAddr::new(IpAddr::V4(Ipv4Addr::new(0, 0, 0, 0)), 0)
    }

    pub fn get_rendezvous_server() -> String {
        let mut rendezvous_server = Self::get_option("custom-rendezvous-server");
        if rendezvous_server.is_empty() {
            rendezvous_server = PROD_RENDEZVOUS_SERVER.read().unwrap().clone();
        }
        if rendezvous_server.is_empty() {
            rendezvous_server = CONFIG2.read().unwrap().rendezvous_server.clone();
        }
        if rendezvous_server.is_empty() {
            rendezvous_server = Self::get_rendezvous_servers()
                .drain(..)
                .next()
                .unwrap_or("".to_owned());
        }
        if !rendezvous_server.contains(":") {
            rendezvous_server = format!("{}:{}", rendezvous_server, RENDEZVOUS_PORT);
        }
        rendezvous_server
    }

    pub fn get_rendezvous_servers() -> Vec<String> {
        let s = Self::get_option("custom-rendezvous-server");
        if !s.is_empty() {
            return vec![s];
        }
        let s = PROD_RENDEZVOUS_SERVER.read().unwrap().clone();
        if !s.is_empty() {
            return vec![s];
        }
        let serial_obsolute = CONFIG2.read().unwrap().serial > SERIAL;
        if serial_obsolute {
            let ss: Vec<String> = Self::get_option("rendezvous-servers")
                .split(",")
                .filter(|x| x.contains("."))
                .map(|x| x.to_owned())
                .collect();
            if !ss.is_empty() {
                return ss;
            }
        }
        return RENDEZVOUS_SERVERS.iter().map(|x| x.to_string()).collect();
    }

    pub fn reset_online() {
        *ONLINE.lock().unwrap() = Default::default();
    }

    pub fn update_latency(host: &str, latency: i64) {
        ONLINE.lock().unwrap().insert(host.to_owned(), latency);
        let mut host = "".to_owned();
        let mut delay = i64::MAX;
        for (tmp_host, tmp_delay) in ONLINE.lock().unwrap().iter() {
            if tmp_delay > &0 && tmp_delay < &delay {
                delay = tmp_delay.clone();
                host = tmp_host.to_string();
            }
        }
        if !host.is_empty() {
            let mut config = CONFIG2.write().unwrap();
            if host != config.rendezvous_server {
                log::debug!("Update rendezvous_server in config to {}", host);
                log::debug!("{:?}", *ONLINE.lock().unwrap());
                config.rendezvous_server = host;
                config.store();
            }
        }
    }

    pub fn set_id(id: &str) {
        let mut config = CONFIG.write().unwrap();
        if id == config.id {
            return;
        }
        config.id = id.into();
        config.store();
    }

    pub fn set_nat_type(nat_type: i32) {
        let mut config = CONFIG2.write().unwrap();
        if nat_type == config.nat_type {
            return;
        }
        config.nat_type = nat_type;
        config.store();
    }

    pub fn get_nat_type() -> i32 {
        CONFIG2.read().unwrap().nat_type
    }

    pub fn set_serial(serial: i32) {
        let mut config = CONFIG2.write().unwrap();
        if serial == config.serial {
            return;
        }
        config.serial = serial;
        config.store();
    }

    pub fn get_serial() -> i32 {
        std::cmp::max(CONFIG2.read().unwrap().serial, SERIAL)
    }

    fn get_auto_id() -> Option<String> {
        #[cfg(any(target_os = "android", target_os = "ios"))]
        {
            return Some(
                rand::thread_rng()
                    .gen_range(1_000_000_000..2_000_000_000)
                    .to_string(),
            );
        }

        #[cfg(not(any(target_os = "android", target_os = "ios")))]
        {
            let mut id = 0u32;
            if let Ok(Some(ma)) = mac_address::get_mac_address() {
                for x in &ma.bytes()[2..] {
                    id = (id << 8) | (*x as u32);
                }
                id = id & 0x1FFFFFFF;
                Some(id.to_string())
            } else {
                None
            }
        }
    }

    pub fn get_auto_password(length: usize) -> String {
        let mut rng = rand::thread_rng();
        (0..length)
            .map(|_| CHARS[rng.gen::<usize>() % CHARS.len()])
            .collect()
    }

    pub fn get_key_confirmed() -> bool {
        CONFIG.read().unwrap().key_confirmed
    }

    pub fn set_key_confirmed(v: bool) {
        let mut config = CONFIG.write().unwrap();
        if config.key_confirmed == v {
            return;
        }
        config.key_confirmed = v;
        if !v {
            config.keys_confirmed = Default::default();
        }
        config.store();
    }

    pub fn get_host_key_confirmed(host: &str) -> bool {
        if let Some(true) = CONFIG.read().unwrap().keys_confirmed.get(host) {
            true
        } else {
            false
        }
    }

    pub fn set_host_key_confirmed(host: &str, v: bool) {
        if Self::get_host_key_confirmed(host) == v {
            return;
        }
        let mut config = CONFIG.write().unwrap();
        config.keys_confirmed.insert(host.to_owned(), v);
        config.store();
    }

    pub fn get_key_pair() -> (Vec<u8>, Vec<u8>) {
        // lock here to make sure no gen_keypair more than once
        // no use of CONFIG directly here to ensure no recursive calling in Config::load because of password dec which calling this function
        let mut lock = KEY_PAIR.lock().unwrap();
        if let Some(p) = lock.as_ref() {
            return p.clone();
        }
        let mut config = Config::load_::<Config>("");
        if config.key_pair.0.is_empty() {
            let (pk, sk) = sign::gen_keypair();
            let key_pair = (sk.0.to_vec(), pk.0.into());
            config.key_pair = key_pair.clone();
            std::thread::spawn(|| {
                let mut config = CONFIG.write().unwrap();
                config.key_pair = key_pair;
                config.store();
            });
        }
        *lock = Some(config.key_pair.clone());
        return config.key_pair;
    }

    pub fn get_id() -> String {
        let mut id = CONFIG.read().unwrap().id.clone();
        if id.is_empty() {
            if let Some(tmp) = Config::get_auto_id() {
                id = tmp;
                Config::set_id(&id);
            }
        }
        id
    }

    pub fn get_id_or(b: String) -> String {
        let a = CONFIG.read().unwrap().id.clone();
        if a.is_empty() {
            b
        } else {
            a
        }
    }

    pub fn get_options() -> HashMap<String, String> {
        CONFIG2.read().unwrap().options.clone()
    }

    pub fn set_options(v: HashMap<String, String>) {
        let mut config = CONFIG2.write().unwrap();
        if config.options == v {
            return;
        }
        config.options = v;
        config.store();
    }

    pub fn get_option(k: &str) -> String {
        if let Some(v) = CONFIG2.read().unwrap().options.get(k) {
            v.clone()
        } else {
            "".to_owned()
        }
    }

    pub fn set_option(k: String, v: String) {
        let mut config = CONFIG2.write().unwrap();
        let v2 = if v.is_empty() { None } else { Some(&v) };
        if v2 != config.options.get(&k) {
            if v2.is_none() {
                config.options.remove(&k);
            } else {
                config.options.insert(k, v);
            }
            config.store();
        }
    }

    pub fn update_id() {
        // to-do: how about if one ip register a lot of ids?
        let id = Self::get_id();
        let mut rng = rand::thread_rng();
        let new_id = rng.gen_range(1_000_000_000..2_000_000_000).to_string();
        Config::set_id(&new_id);
        log::info!("id updated from {} to {}", id, new_id);
    }

    pub fn set_permanent_password(password: &str) {
        let mut config = CONFIG.write().unwrap();
        if password == config.password {
            return;
        }
        config.password = password.into();
        config.store();
    }

    pub fn get_permanent_password() -> String {
        CONFIG.read().unwrap().password.clone()
    }

    pub fn set_salt(salt: &str) {
        let mut config = CONFIG.write().unwrap();
        if salt == config.salt {
            return;
        }
        config.salt = salt.into();
        config.store();
    }

    pub fn get_salt() -> String {
        let mut salt = CONFIG.read().unwrap().salt.clone();
        if salt.is_empty() {
            salt = Config::get_auto_password(6);
            Config::set_salt(&salt);
        }
        salt
    }

    pub fn set_socks(socks: Option<Socks5Server>) {
        let mut config = CONFIG2.write().unwrap();
        if config.socks == socks {
            return;
        }
        config.socks = socks;
        config.store();
    }

    pub fn get_socks() -> Option<Socks5Server> {
        CONFIG2.read().unwrap().socks.clone()
    }

    pub fn get_network_type() -> NetworkType {
        match &CONFIG2.read().unwrap().socks {
            None => NetworkType::Direct,
            Some(_) => NetworkType::ProxySocks,
        }
    }

    pub fn get() -> Config {
        return CONFIG.read().unwrap().clone();
    }

    pub fn set(cfg: Config) -> bool {
        let mut lock = CONFIG.write().unwrap();
        if *lock == cfg {
            return false;
        }
        *lock = cfg;
        lock.store();
        true
    }

    fn with_extension(path: PathBuf) -> PathBuf {
        let ext = path.extension();
        if let Some(ext) = ext {
            let ext = format!("{}.toml", ext.to_string_lossy());
            path.with_extension(&ext)
        } else {
            path.with_extension("toml")
        }
    }
}

const PEERS: &str = "peers";

impl PeerConfig {
    pub fn load(id: &str) -> PeerConfig {
        let _lock = CONFIG.read().unwrap();
        match confy::load_path(&Self::path(id)) {
            Ok(config) => {
                let mut config: PeerConfig = config;
                let mut store = false;
                let (password, _, store2) =
                    decrypt_vec_or_original(&config.password, PASSWORD_ENC_VERSION);
                config.password = password;
                store = store || store2;
                config.options.get_mut("rdp_password").map(|v| {
                    let (password, _, store2) = decrypt_str_or_original(v, PASSWORD_ENC_VERSION);
                    *v = password;
                    store = store || store2;
                });
                config.options.get_mut("os-password").map(|v| {
                    let (password, _, store2) = decrypt_str_or_original(v, PASSWORD_ENC_VERSION);
                    *v = password;
                    store = store || store2;
                });
                if store {
                    config.store(id);
                }
                config
            }
            Err(err) => {
                log::error!("Failed to load config: {}", err);
                Default::default()
            }
        }
    }

    pub fn store(&self, id: &str) {
        let _lock = CONFIG.read().unwrap();
        let mut config = self.clone();
        config.password = encrypt_vec_or_original(&config.password, PASSWORD_ENC_VERSION);
        config
            .options
            .get_mut("rdp_password")
            .map(|v| *v = encrypt_str_or_original(v, PASSWORD_ENC_VERSION));
        config
            .options
            .get_mut("os-password")
            .map(|v| *v = encrypt_str_or_original(v, PASSWORD_ENC_VERSION));
        if let Err(err) = store_path(Self::path(id), config) {
            log::error!("Failed to store config: {}", err);
        }
    }

    pub fn remove(id: &str) {
        fs::remove_file(&Self::path(id)).ok();
    }

    fn path(id: &str) -> PathBuf {
        let id_encoded: String;

        //If the id contains invalid chars, encode it
        let forbidden_paths = Regex::new(r".*[<>:/\\|\?\*].*").unwrap();
        if forbidden_paths.is_match(id) {
            id_encoded =
                "base64_".to_string() + base64::encode(id, base64::Variant::Original).as_str();
        } else {
            id_encoded = id.to_string();
        }
        let path: PathBuf = [PEERS, id_encoded.as_str()].iter().collect();
        Config::with_extension(Config::path(path))
    }

    pub fn peers() -> Vec<(String, SystemTime, PeerConfig)> {
        if let Ok(peers) = Config::path(PEERS).read_dir() {
            if let Ok(peers) = peers
                .map(|res| res.map(|e| e.path()))
                .collect::<Result<Vec<_>, _>>()
            {
                let mut peers: Vec<_> = peers
                    .iter()
                    .filter(|p| {
                        p.is_file()
                            && p.extension().map(|p| p.to_str().unwrap_or("")) == Some("toml")
                    })
                    .map(|p| {
                        let t = crate::get_modified_time(&p);
                        let id = p
                            .file_stem()
                            .map(|p| p.to_str().unwrap_or(""))
                            .unwrap_or("")
                            .to_owned();

                        let id_decoded_string: String;
                        if id.starts_with("base64_") && id.len() != 7 {
                            let id_decoded = base64::decode(&id[7..], base64::Variant::Original)
                                .unwrap_or(Vec::new());
                            id_decoded_string =
                                String::from_utf8_lossy(&id_decoded).as_ref().to_owned();
                        } else {
                            id_decoded_string = id;
                        }

                        let c = PeerConfig::load(&id_decoded_string);
                        if c.info.platform.is_empty() {
                            fs::remove_file(&p).ok();
                        }
                        (id_decoded_string, t, c)
                    })
                    .filter(|p| !p.2.info.platform.is_empty())
                    .collect();
                peers.sort_unstable_by(|a, b| b.1.cmp(&a.1));
                return peers;
            }
        }
        Default::default()
    }

    serde_field_string!(
        default_view_style,
        deserialize_view_style,
        "original".to_owned()
    );
    serde_field_string!(
        default_scroll_style,
        deserialize_scroll_style,
        "scrollauto".to_owned()
    );
    serde_field_string!(
        default_image_quality,
        deserialize_image_quality,
        "balanced".to_owned()
    );

    fn deserialize_options<'de, D>(deserializer: D) -> Result<HashMap<String, String>, D::Error>
    where
        D: de::Deserializer<'de>,
    {
        let mut mp: HashMap<String, String> = de::Deserialize::deserialize(deserializer)?;
        if !mp.contains_key("codec-preference") {
            mp.insert("codec-preference".to_owned(), "auto".to_owned());
        }
        Ok(mp)
    }
}

#[derive(Debug, Default, Serialize, Deserialize, Clone)]
pub struct LocalConfig {
    #[serde(default)]
    remote_id: String, // latest used one
    #[serde(default)]
    size: Size,
    #[serde(default)]
    pub fav: Vec<String>,
    #[serde(default)]
    options: HashMap<String, String>,
    // Various data for flutter ui
    #[serde(default)]
    ui_flutter: HashMap<String, String>,
}

impl LocalConfig {
    fn load() -> LocalConfig {
        Config::load_::<LocalConfig>("_local")
    }

    fn store(&self) {
        Config::store_(self, "_local");
    }

    pub fn get_size() -> Size {
        LOCAL_CONFIG.read().unwrap().size
    }

    pub fn set_size(x: i32, y: i32, w: i32, h: i32) {
        let mut config = LOCAL_CONFIG.write().unwrap();
        let size = (x, y, w, h);
        if size == config.size || size.2 < 300 || size.3 < 300 {
            return;
        }
        config.size = size;
        config.store();
    }

    pub fn set_remote_id(remote_id: &str) {
        let mut config = LOCAL_CONFIG.write().unwrap();
        if remote_id == config.remote_id {
            return;
        }
        config.remote_id = remote_id.into();
        config.store();
    }

    pub fn get_remote_id() -> String {
        LOCAL_CONFIG.read().unwrap().remote_id.clone()
    }

    pub fn set_fav(fav: Vec<String>) {
        let mut lock = LOCAL_CONFIG.write().unwrap();
        if lock.fav == fav {
            return;
        }
        lock.fav = fav;
        lock.store();
    }

    pub fn get_fav() -> Vec<String> {
        LOCAL_CONFIG.read().unwrap().fav.clone()
    }

    pub fn get_option(k: &str) -> String {
        if let Some(v) = LOCAL_CONFIG.read().unwrap().options.get(k) {
            v.clone()
        } else {
            "".to_owned()
        }
    }

    pub fn set_option(k: String, v: String) {
        let mut config = LOCAL_CONFIG.write().unwrap();
        let v2 = if v.is_empty() { None } else { Some(&v) };
        if v2 != config.options.get(&k) {
            if v2.is_none() {
                config.options.remove(&k);
            } else {
                config.options.insert(k, v);
            }
            config.store();
        }
    }

    pub fn get_flutter_config(k: &str) -> String {
        if let Some(v) = LOCAL_CONFIG.read().unwrap().ui_flutter.get(k) {
            v.clone()
        } else {
            "".to_owned()
        }
    }

    pub fn set_flutter_config(k: String, v: String) {
        let mut config = LOCAL_CONFIG.write().unwrap();
        let v2 = if v.is_empty() { None } else { Some(&v) };
        if v2 != config.ui_flutter.get(&k) {
            if v2.is_none() {
                config.ui_flutter.remove(&k);
            } else {
                config.ui_flutter.insert(k, v);
            }
            config.store();
        }
    }
}

#[derive(Debug, Default, Serialize, Deserialize, Clone)]
pub struct DiscoveryPeer {
    #[serde(default)]
    pub id: String,
    #[serde(default)]
    pub username: String,
    #[serde(default)]
    pub hostname: String,
    #[serde(default)]
    pub platform: String,
    #[serde(default)]
    pub online: bool,
    #[serde(default)]
    pub ip_mac: HashMap<String, String>,
}

impl DiscoveryPeer {
    pub fn is_same_peer(&self, other: &DiscoveryPeer) -> bool {
        self.id == other.id && self.username == other.username
    }
}

#[derive(Debug, Default, Serialize, Deserialize, Clone)]
pub struct LanPeers {
    pub peers: Vec<DiscoveryPeer>,
}

impl LanPeers {
    pub fn load() -> LanPeers {
        let _lock = CONFIG.read().unwrap();
        match confy::load_path(&Config::file_("_lan_peers")) {
            Ok(peers) => peers,
            Err(err) => {
                log::error!("Failed to load lan peers: {}", err);
                Default::default()
            }
        }
    }

    pub fn store(peers: &Vec<DiscoveryPeer>) {
        let f = LanPeers {
            peers: peers.clone(),
        };
        if let Err(err) = store_path(Config::file_("_lan_peers"), f) {
            log::error!("Failed to store lan peers: {}", err);
        }
    }

    pub fn modify_time() -> crate::ResultType<u64> {
        let p = Config::file_("_lan_peers");
        Ok(fs::metadata(p)?
            .modified()?
            .duration_since(SystemTime::UNIX_EPOCH)?
            .as_millis() as _)
    }
}

#[derive(Debug, Default, Serialize, Deserialize, Clone)]
pub struct HwCodecConfig {
    #[serde(default)]
    pub options: HashMap<String, String>,
}

impl HwCodecConfig {
    pub fn load() -> HwCodecConfig {
        Config::load_::<HwCodecConfig>("_hwcodec")
    }

    pub fn store(&self) {
        Config::store_(self, "_hwcodec");
    }

    pub fn remove() {
        std::fs::remove_file(Config::file_("_hwcodec")).ok();
    }

    /// refresh current global HW_CODEC_CONFIG, usually uesd after HwCodecConfig::remove()
    pub fn refresh() {
        *HW_CODEC_CONFIG.write().unwrap() = HwCodecConfig::load();
        log::debug!("HW_CODEC_CONFIG refreshed successfully");
    }

    pub fn get() -> HwCodecConfig {
        return HW_CODEC_CONFIG.read().unwrap().clone();
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_serialize() {
        let cfg: Config = Default::default();
        let res = toml::to_string_pretty(&cfg);
        assert!(res.is_ok());
        let cfg: PeerConfig = Default::default();
        let res = toml::to_string_pretty(&cfg);
        assert!(res.is_ok());
    }
}
